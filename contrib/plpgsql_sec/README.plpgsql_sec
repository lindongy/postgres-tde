plpgsql_sec v12.x
------------------

An encrypted PL/pgSQL implementation that encrypts and decrypts function
bodies on the fly. It helps hiding implementation of PL/pgSQL functions.

Usage
-----

OpenSSL library is used to perform the encryption / decryption. Therefore,
make sure that the --with-openssl option is used to configure the build of the
PostgreSQL server.

./configure ... --with-openssl ...

To compile the plpgsql_sec code, do the following:

$ cd contrib/plpgsql_sec

$ make

Installation as root:

# make install

or using sudo:

$ sudo make install

Before you start the server, make sure that this setting is in place:

shared_preload_libraries = 'plpgsql'

Also make sure that the user "plpgsql_sec" exists and that it has password
set. For example:

CREATE ROLE plpgsql_sec PASSWORD 'securepassword';

This role's password will be used to derive the encryption key that will
eventually be used to encrypt the functions. By default, the key is derived by
computing md5 sum of the password, but if you prefer the sha-256 digest,
please adjust the "password_encryption" configuration variable before you run
the CREATE ROLE command:

SET password_encryption TO 'scram-sha-256';

Then using a PostgreSQL client (like psql from the command line or pgAdmin)
this command must be executed as the database superuser:

dbname=# CREATE EXTENSION plpgsql_sec;

From this point when a PL/pgSQL function is created this way:

CREATE OR REPLACE FUNCTION func_name(... ) ... LANGUAGE plpgsql_sec;

then the function body is stored in an encrypted way which can be recognized
later.

If such a function is dumped and reloaded then the encryption scheme is
recognized and encryption is skipped, the function is stored with the already
provided encryption.

CAUTION: If you change the encryption password, you need to create all the
encrypted functions from plain text again. Otherwise the PostgreSQL server
will no longer be able to decrypt and run the existing functions. Also, you
need to restart the server to make sure that all backends (connections) use
the new password.


Implementation details:
-----------------------

AES cipher in CTR mode is used. The key is derived from password of the
'plpgsql_sec' user. If the password type is MD5, then the key length is 128
bits (16 bytes). If the password type is SCRAM-SHA-256, then the key length is
256 bits (32 bytes).

The function body when encrypted is stored as text as follows:

<space>#ENCRYPTED#<bytes-in-hex><space>

where <bytes-in-hex> is the encrypted function body converted
from type bytea to type text using encode( ... , 'hex').

Encryption is done at function validation time regardless of the setting of
the GUC variable "check_function_bodies". This setting is used globally for
all languages for e.g. syntax checking at CREATE FUNCTION time. When this
variable is set to false, functions can be created without actually checking
them and syntax errors will be discovered at the first run.

Decryption is done when the function is compiled. Compilation may happen at
function validation or at first run.

This will result in slightly slower performance when the function is created
and at the first run of the function in other client connections. The
functions' execution tree is cached so there won't be any performance hit
after the first run.

2007-2020 Cybertec Schönig & Schönig GmbH