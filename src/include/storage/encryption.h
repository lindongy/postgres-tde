/*-------------------------------------------------------------------------
 *
 * encryption.h
 *	  Full database encryption support
 *
 *
 * Portions Copyright (c) 1996-2015, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * src/include/storage/encryption.h
 *
 *-------------------------------------------------------------------------
 */
#ifndef ENCRYPTION_H
#define ENCRYPTION_H

#include "access/xlogdefs.h"
#include "port/pg_crc32c.h"
#include "lib/ilist.h"

#ifdef USE_OPENSSL
/*
 * Full database encryption key.
 *
 * EVP_aes_256_xts() needs the key twice as long as AES would do in general.
 */
#define	ENCRYPTION_KEY_LENGTH	64

/*
 * TODO Tune these values.
 */
#define ENCRYPTION_PWD_MIN_LENGTH	8
#define ENCRYPTION_PWD_MAX_LENGTH	16
#define ENCRYPTION_KDF_NITER		1048576
#define	ENCRYPTION_KDF_SALT_LEN		8

extern unsigned char	*encryption_key;
#endif	/* USE_OPENSSL */

/*
 * The encrypted data is a series of blocks of size
 * ENCRYPTION_BLOCK. Currently we use the EVP_aes_256_xts implementation. Make
 * sure the following constants match if adopting another algorithm.
 */
#define ENCRYPTION_BLOCK 16

#ifdef	USE_OPENSSL
/*
 * The openssl EVP API refers to a block in terms of padding of the output
 * chunk. That's the purpose of this constant. However the openssl
 * implementation of AES XTS still uses the 16-byte block internally, as
 * defined by ENCRYPTION_BLOCK.
 */
#define ENCRYPTION_BLOCK_OPENSSL 1

#define TWEAK_SIZE 16

#define KDF_PARAMS_FILE			"global/pg_keysetup"
#define KDF_PARAMS_FILE_SIZE	512

/*
 * Key derivation function.
 */
typedef enum KDFKind {
	KDF_OPENSSL_PKCS5_PBKDF2_HMAC_SHA = 0
} KFDKind;

typedef struct KDFParamsPBKDF2
{
	unsigned long int	niter;
	unsigned char		salt[ENCRYPTION_KDF_SALT_LEN];
} KDFParamsPBKDF2;

/*
 * Parameters of the key derivation function.
 *
 * The parameters are generated by initdb and stored into a file, which is
 * then read during PG startup. This is similar to storing various settings in
 * pg_control. However an existing KDF file is read only, so it does not have
 * to be stored in shared memory.
 */
typedef struct KDFParamsData
{
	KFDKind		function;

	/*
	 * Function-specific parameters.
	 */
	union
	{
		KDFParamsPBKDF2	pbkdf2;
	} data;

	/* CRC of all above ... MUST BE LAST! */
	pg_crc32c	crc;
} KDFParamsData;

extern KDFParamsData	*KDFParams;
#endif	/* USE_OPENSSL */

extern PGDLLIMPORT bool data_encrypted;

#ifdef USE_OPENSSL
#ifndef FRONTEND
extern void write_kdf_file(void);
extern void read_kdf_file(void);
#endif	/* FRONTEND */

extern PGDLLIMPORT char	*encryption_key_command;

extern char	*encryption_buffer;
extern Size	encryption_buf_size;

extern void enlarge_encryption_buffer(Size new_size);
#endif

/*
 * If one XLOG record ended and the following one started in the same block,
 * we'd have to either encrypt and decrypt both records together, or encrypt
 * (after having zeroed the part of the block occupied by the other record)
 * and decrypt them separate. Neither approach is compatible with streaming
 * replication. In the first case we can't ask standby not to decrypt the
 * first record until the second has been streamed. The second approach would
 * imply streaming of two different versions of the same block two times.
 *
 * We avoid this problem by aligning XLOG records to the encryption block
 * size. This way no adjacent XLOG records should appear in the same block.
 *
 * For similar reasons, the alignment to ENCRYPTION_BLOCK also has to be
 * applied when storing changes to disk in reorderbuffer.c. Another module
 * that takes the block into account is buffile.c.
 *
 * TODO If the configuration allows walsender to decrypt the XLOG stream
 * before sending it, adjust this expression so that the additional padding is
 * not added to XLOG records. (Since the XLOG alignment cannot change without
 * initdb, the same would apply to the configuration variable that makes
 * walsender perform the decryption. Does such a variable make sense?)
 */
#define DO_ENCRYPTION_BLOCK_ALIGN	data_encrypted

/*
 * Use TYPEALIGN64 since besides record size we also need to align XLogRecPtr.
 */
#define ENCRYPTION_BLOCK_ALIGN(LEN)		TYPEALIGN64(ENCRYPTION_BLOCK, (LEN))

/*
 * Universal computation of XLOG record alignment.
 */
#define XLOG_REC_ALIGN(LEN) ((DO_ENCRYPTION_BLOCK_ALIGN) ?\
							 ENCRYPTION_BLOCK_ALIGN(LEN) : MAXALIGN64(LEN))

extern void setup_encryption(bool bootstrap);
extern void setup_encryption_key(char *credentials, bool is_key, size_t len);
extern void sample_encryption(char *buf);
extern void encrypt_block(const char *input, char *output, Size size,
						  const char *tweak);
extern void decrypt_block(const char *input, char *output, Size size,
						  const char *tweak);
#ifndef OPENSSL
extern void encryption_error(bool fatal, char *message);
#endif

extern void XLogEncryptionTweak(char *tweak, XLogSegNo segment,
								uint32 offset);

#endif   /* ENCRYPTION_H */
