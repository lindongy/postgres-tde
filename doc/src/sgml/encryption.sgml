<!-- doc/src/sgml/encryption.sgml -->

<chapter id="encryption">
 <title>Transparent Cluster Encryption</title>

 <para>
  Cluster encryption can be used if <acronym>DBA</acronym> cannot or does not
  want to rely on the filesystem in terms of data confidentiality. If this
  feature is enabled, <productname>PostgreSQL</productname> encrypts data
  (both relations and write-ahead-log) when writing it to disk, and decrypts
  when reading it. The encryption is transparent, so applications see no
  difference between encrypted and unencrypted cluster.
 </para>

 <para>
  To create encrypted cluster, use the <option>-K</option> option to pass the
  <xref linkend="app-initdb"/> utility path to the command that will retrieve
  the encryption key. For example:
<screen>
<prompt>$</prompt> <userinput>initdb -D /usr/local/pgsql/data -K /usr/local/pgsql/fetch_key_cmd</userinput>
</screen>
  Here <filename>/usr/local/pgsql/fetch_key_cmd</filename> is an executable
  file that writes the encryption key to its standard output and returns
  zero. The simplest command looks like:

<programlisting>
echo &lt;your key&gt;
</programlisting>
 </para>

 <para>
   The encryption key is expected in hexadecimal format, two characters
   (hexadecimal digits) per byte. Since <productname>PostgreSQL</productname>
   currently uses key of length 32 bytes (128 bits), the expected length of
   the key string is 32 characters. For example:
   <computeroutput>
     882fb7c12e80280fd664c69d2d636913
   </computeroutput>
 </para>

 <para>
   <application>initdb</application> eventually puts the encryption key
   command into <filename>postgresql.conf</filename> file, as the value
   of <literal>encryption_key_command</literal> parameter. That ensures that
   you don't need to pass it to <application>pg_ctl</application> each time
   you want to start the server.
 </para>

 <para>
   If the you want to enter password, you can use
   <xref linkend="app-pg-keytool"/> utility to derive ecryption key from
   it. For example, if the <option>-K</option> option looks like in the
   following example, the DBA will be asked for password interactively:

<screen>
<prompt>$</prompt> <userinput>initdb -K 'read -sp "Cluster encryption password: " PGENCRPWD; echo $PGENCRPWD | pg_keytool -D %D -w' -D data
</userinput>
</screen>

 </para>

 <para>
   As long as <application>pg_keytool</application> is called
   by <application>initdb</application>, you can put <literal>%D</literal>
   into the command and
   <application>initdb</application> will replace it with the actual directory
   path. Note however that only the actual value of the <option>-K</option>
   option is subject to this replacement. No replacement will take place
   if <application>pg_keytool</application> is called from a shell script
   whose path is passed to <application>initdb</application> via
   the <option>-K</option> option. In such a case it may be easier to pass the
   data directory to
   <application>pg_keytool</application> via <envar>PGDATA</envar> environment
   variable.
 </para>

 <note>
   <para>
     If the encryption key command needs to read the password from console
     like this one, you need to comment out
     the <literal>encryption_key_command</literal> parameter
     in <filename>postgresql.conf</filename> and pass the command
     to <application>pg_ctl</application> as explained below.
   </para>
 </note>

 <para>
   If the <literal>encryption_key_command</literal> setting is not present
   in <filename>postgresql.conf</filename>, and if the server supports
   Unix-domain sockets, the command can be passed to
   <xref linkend="app-pg-ctl"/> when starting the cluster:

<screen>
<prompt>$</prompt> <userinput>pg_ctl -K 'read -sp "Cluster encryption
  password: " PGENCRPWD; echo $PGENCRPWD | pg_keytool -D %D -w' -D data start
</userinput>
</screen>
 </para>

 <para>
  Once the <productname>PostgreSQL</productname> server is running, client
  applications should recognize no difference from an unencrypted cluster,
  except that <xref linkend="guc-data-encryption"/> variable is set.
 </para>

 <para>
  Since WAL is encrypted, any replication solution based on log shipping
  (<xref linkend="warm-standby"/>) assumes that all standby servers are
  encrypted using the same key as their primary server. On the other hand,
  <xref linkend="logical-replication"/> allows replication between encrypted
  and unencrypted clusters, or between clusters encrypted with different keys.
 </para>
</chapter>
